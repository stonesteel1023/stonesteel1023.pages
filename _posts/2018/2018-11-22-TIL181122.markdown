---
layout: post
title: "객체지향 특성과 설계시 원칙"
date: 2018-11-22 10:55
comments: true
tag : java
---

# 객체지향의 4대 특성 (클래스, 객체, 인스턴스, 캡슐화, 상속, 추상화, 다형성)

## 클래스와 객체

가장 흔한 설명중에 대표적으로 잘못된 것은 붕어빵이야기다. 클래스 = 붕어빵틀, 객체 = 붕어빵에 비유하며, 붕어빵틀에서 붕어빵을 찍어낸다는 이야기다. 하지만 코드로 보면 이 비유는 틀렸다. 클래스 객체변수명 = new 클래스(); 에 대입해보면, 붕어빵틀 붕어빵 = new 붕어빵틀(); 이다. 말이 안되는 예제이다. 여기서 붕어빵틀은 붕어빵을 만드는 Factory로 이해를 해야지, 클래스와 객체관계로 이해하면 안된다. 클래스는 추상적이고, 클래스라는 단어대로 분류에 대한 개념이지, 실체가 아니다. 하지만 객체는 실체이다. class Person이 있고, Person ljh = new Person(); 이 말이 되는 것이다.
* 클래스 : 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념
* 객체 : unique한 사물, 생물
* 객체와 인스턴스

일반적으로 설계도인 클래스가 구체적인 실체인 인스턴스가 되었을 때 객체라고 부른다. 보통은 구체적인 코드 상에서 나타는 객체를 인스턴스라고 부르고, 로직을 설계 할 때 나타나는 인스턴스를 객체라고 부른다.

### 1. 캡슐화(Encapsulation) = 정보 은닉

접근제어자(private, protected, public)를 사용해 객체 외부에서 내부 데이터의 접근을 통제하는 것이다. 보통 public한 메소드에서만 접근가능하게 해서, 인터페이싱을 맞춘다.

### 2. 상속(Inheritance) = 재사용 + 확장

상속에서 주의할 점은 위처럼 계층도, 조직도 관점(할아버지를 상속받은 아버지?)에서 이해하면 안된다.

분류도 관점에서 이해해야한다. 포유류의 부모가 동물은 아니지만, class 포유류 extends 동물로 충분히 구현된다. 객체지향에서 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 더 필요한 속성을 확장해서 쓰는 것이다. 애초에 extends 라는 키워드만 보아도 java의 의도를 알 수있다. 메모리관점에서는 하위클래스의 인스턴스가 생성될 때, 상위클래스의 인스턴스도 같이 생성된다. (생성자가 호출되는 걸 보면 알 수 있음) 당연히 lang.Object도 생성된다. (그러니까 toString()을 쓸 수 있는 것)
상속관계에서 만족해야하는 조건

상속관계에서 반드시 만족해야하는 문장들이 있다.
* 하위클래스는 상위클래스이다.
* 하위클래스 is a kind of 상위클래스
* 상속과 인터페이스

구현클래스 is able to 인터페이스 일 때 사용하면 좋다. 자바 api에서는 Runnable, Serializable 등을 예로들 수 있다. 인터페이스명도 *able 형태로 쓰면 좋을듯. 상위클래스는 물려줄 특성이 풍성할 수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.

### 3. 추상화(Abstraction) = 모델링

객체지향의 추상화는 모델링이다. 추상화란 구체적인 것을 관심영역(해당 애플리케이션, 서비스의 도메인)에 있는 특성만을 가지고 재조합하는 것을 말한다. 예를들어 class Person은 병원이라면 환자 도메인에 맞는 속성이 좀 더 많을 것이고, 상점이라면 고객입장에서의 속성이 좀 더 많을 것이다.

### 4. 다형성(Polymorphism) = 사용편의

오버라이딩(overriding)과 오버로딩(overloading)이 여기에 해당된다. 오버라이딩은 상위클래스의 메서드와 같은 시그니처(이름, 반환형, 인자)로 메소드를 재정의하는 것을 말한다. 오버로딩은 메소드이름만 같고 시그니처가 다른 것들을 말한다.
이때 유의할 점은 변수타입을 상위클래스로 써서, 메소드를 호출한다고 해도 하위클래스에서 오버라이딩한 메소드의 로직이 호출된다는 점이다. 

# 객체지향 설계 5원칙 SOLID (SRP, OCP, LSP, ISP, DIP)

> 참조문서
  http://www.nextree.co.kr/p6960/
  http://slenderankle.tistory.com/162


## SOLID란?

객체지향 설계는 긴 세월과 수많은 시행착오를 거치며 5가지 원칙이 정리되었다. 이것은 객체지향 설계의 5원칙이라고 하며, 앞글자를 따서 SOLID라고 한다.
* SPR(Single Responsibility Principle) : 단일 책임 원칙
* OCP(Open Closed Principle) : 개방 폐쇄 원칙
* LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
* ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
* DIP(Dependency Inversion Principle) : 의존 역전 원칙
이 원칙들은 응집도는 높이고 결합도는 낮추자는 고전 원칙을 객체 지향의 관점에서 재정립한 것으로 볼 수 있다.

### 1. SRP = 단일 책임 원칙

어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.
SRP가 안지켜진 사례

변수레벨
하나의 속성이 여러 의미를 갖는 경우
어떤 곳에서는 쓰고, 어떤 곳에선 안쓰는 속성이 있는 경우
메소드레벨
분기처리를 위한 if문이 많을 경우

### 2. OCP = 개방 폐쇄 원칙

소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. 즉, 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다는 것이다. 이것은 interface 를 통해 구현하여 해결한다.
현실의 예를들면 상점직원이 아무리 바뀐다고해서 손님이 상품을 구매하는 데는 지장이 없다. 이는 직원은 판매 인터페이스를 구현해야하기 때문이다. 손님은 판매인터페이스와 소통하기 때문에 직원이 누구든 지장이 없다.

### 3. LSP = 리스코프 치환 원칙

서브타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다. 즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 수행하는 데 문제가 없어야 한다. 이것은 OOP 4대 특성의 상속, 인터페이스 원칙이 잘 지켜진 다면 LSP는 자동으로 잘 적용된 것이다. (주로 조직도, 계층도 관점에서의 상속이 LSP를 위배하는 문제가 생긴다)

### 4. ISP = 인터페이스 분리 원칙

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다. ISP는 SRP와 비슷하지만 인터페이스를 통한 다른 해결책을 제안하고 있다. 예를들어 class 사람 implements 군인 이면 군인 홍길동 = new 사람() 을 통해 군인 인터페이스의 메소드만을 사용하도록 제한하는 것이다. SRP였다면 class를 나눠버렸겠지만.. 일반적으론 ISP보다 SRP 할 것이 권장된다.

### 5. DIP = 의존 역전 원칙

고차원 모듈은 저차원 모듈에 의존하면 안된다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 클래스에 의존하지 말자. 로 요약될 수 있다. 즉, 자신보다 변하기 쉬운 것에 의존하지 말라는 것이다. 해결방법은 OCP와 비슷한데, 구체적인 class가 아닌, 인터페이스에 의존함으로써 DIP를 해결한다.
