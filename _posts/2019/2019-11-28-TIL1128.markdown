댓글이 아니라 단편 소설입니다. 음료를 한 잔 가져오시고, 느긋하게 읽어주세요. 하하하하하;;;;
순차적인 실행이라는 건 쓰레드의 관점에서만 생각하면 순차적인 게 맞습니다.
그런데 프로그래머가 프로그램을 작성할 때는 이게 순차적으로 실행될건지 아닌지만 고려해서 설계를 하지 않습니다.
극단적으로 보면, 어차피 프로그램은 루프 도는 거고, 다 순차 실행될 거, 함수 호출 부하라도 줄이도록 전부 WinMain 함수 안에 몰아 넣으면 (함수 호출 부하 측면에서만 보면)최고의 효율이 나는 프로그램이 될겁니다. 옆자리의 동료나 상사에게 구타 당해도 할 말이 없는 건 여기선 생각하지 말구요.

그런데 아무도 이렇게 안 짜죠. 아시다시피 가독성의 문제가 발생합니다. 가독성을 높이려면 사람이 알아보기 편한 형태로 쪼개야겠죠. 그럼 사람이 알아보기 좋게 쪼개면 끝인가? 모든 코드들이 순차적으로 다 실행되는 건 아닐겁니다. 논리적인 판단에 따라 분리가 되는 경우도 있겠죠.

예를 들어, 기획자가 이런 요구를 한다고 해보죠.

    "캐릭터의 HP가 25% 이하가 되면 자동으로 HP 물약을 먹어서, 물약이 있는 한 절대로 죽지 않게 해주세요."

어디 대륙의 게임같은 소릴 하고 있지만, 때론 거부할 수 없는 그런 게 있지요. 해야 합니다. 어떻게 할까요?
크게 두 가지 방법이 나옵니다. 맨날놀아 님께서 말씀하신 두 가지 방법과 비슷한데, 두 번째건 제 임의대로 구체화해봤습니다.

1. 메인 루프의 특정 위치에서 HP를 체크하는 로직을 넣고 이전 프레임에는 25% 초과였는데,
    이번 프레임에 보니 25% 이하더라. 그럼 약을 먹자!

2. HP 수치를 변경하는 수 많은 코드들이 직접 int 데이터를 조작하지 말고 별도의 함수를 사용하도록 한 번 감싸고,
    그 함수 안에서 HP가 25% 초과였다가 25% 이하로 떨어지면 약을 먹자!

불타는키보드님께서 말씀하신대로 어차피 다 순차 실행이라면 1번이나 2번이나 차이가 없을 겁니다. 근데 코드는 잠깐 제껴놓고, 두 가지 구현의 동작 차이점을 한 번 보죠.

1번 방식은 캐릭터가 한 프레임 내에 엄청난 다굴을 당하고, DOT 틱 튀고, 트랩 카드를 발동시키는 등 각종 악재를 겹쳐서 당하면 이번 프레임 시작할 땐 26%의 HP를 갖고 있었는데, 메인 루프 내에서 물약을 먹는 처리를 해주는 구간에 도달하기 전에 사망하실 수 있을 겁니다. 심하면 다음 프레임이 돼서야 물약을 먹으려고 할 수도 있지요. 캐릭터가 죽겠네요?

반면 2번 방식은 HP를 변경하는 함수가 호출되는 순간, HP가 25% 초과였다가 이하로 떨어지는지를 미리 보고, 약을 먹어서 데미지를 상쇄시킬 수 있을겁니다.

이제 2번 방식으로 구현하는게 좋아 보입니다. 그럼 2번 방식으로 구현하는데 콜백 구조가 필요한가? 필요 없습니다. HP를 변경하는 함수가 있기 때문에, 그 함수 안에다 코딩 해버리면 됩니다. 혹은 따로 함수를 만들었어도 그걸 HP 변경하는 함수 안에서 호출하는거니까 그냥 함수 호출입니다.

그런데 우리의 기획자, 여기서 끝날리가 없습니다. 업데이트는 계속 되어야 한다. 다음 기획이 옵니다.

    "캐릭터가 특정 버프를 가지고 있을 때는, HP가 25% 이하가 되면 물약 먹고, 자폭도 하게 해주세요!"

사소한 건 제껴놓고 또 어떻게 만들지를 고민합니다. 2번 방식으로 만들어놓았으니 기존에 25% 이하로 떨어질 때 물약 먹던 함수에서 그 기묘한 버프가 있나 없나를 체크하고, 있으면 자폭도 하게 하면 될 것 같습니다.

근데 여기서 다른 구현 방식을 생각해 볼 수 있습니다. 만일 HP가 25% 초과였다가 이하로 떨어질 때 호출되는 함수가 그냥 함수가 아니라, n.....2 님께서 말씀하신 것처럼 virtual 함수를 갖고 있는 클래스 객체를 이용해서 호출하는 콜백 형태가 된다면? 함수 이름은 OnWounded 정도로 갖다 붙여도 되겠죠.

이러면 그 기묘한 버프가 있나 없나를 HP 떨어졌을 때 체크할 필요 없이, 기묘한 버프가 걸리는 시점에 콜백 함수 객체를 [약 냠냠 + 자폭]용으로 갈아끼워버리면 됩니다. 그리고 HP 떨어진 거 감지한 쪽에서는 콜백 함수 그냥 호출하면 알아서 약 먹고, 자폭하겠죠.(약 왜 먹는지는 기획자에게 물어보세요) 반대로 버프가 사라질 때는 약만 먹고 마는 콜백 함수 객체로 갈아끼워버리면 됩니다.

심지어 [약 냠냠 + 자폭]에서 [약 냠냠]은 다시 구현할 필요 없이, 기존에 있던 걸 호출해버리면 됩니다. 그 후에 자폭만 구현하면 되죠.

여기서 콜백 함수를 virtual 함수를 가지고 있는 클래스 객체라고 설명 드렸지만, 사실 콜백을 구현하는 방법은 다양합니다. 함수 1개라면 객체 대신 함수 포인터를 가지고 있을 수도 있겠죠. 요즘은 std::function 객체를 사용하는 것도 방법일 겁니다. 람다 식으로 작성한 코드도 쓸 수도 있을테니 다음에 25% 이하가 되면 가죽 신발을 먹게 해달라는 기획이 와도 기존의 코드를 손대지 않고 추가되는 부분들만 작업해서 대응할 수 있을 것 같습니다.

기획자에게 고통받는 소설은 여기까지입니다.
콜백이라는 건 단순히 하나의 쓰레드가 순차적으로 처리하느냐 아니냐의 관점이라기보다는, 사람이 프로그램의 구조를 보고 이해할 수 있는 설계의 관점에서 보는게 더 적합합니다. 엑스터님께서 말씀하신 쓰레드와 무관하다는 건 이 부분을 말씀하시고자 한 거라고 생각합니다.

루프라고 해서 루프 안에 모든 코드를 박는게 능사가 아니듯이, 상황마다 if/else 해가며 조건을 체크하는 게 능사가 아닌 경우도 많습니다. 위에 예시는 좀 엉뚱했지만, 특정 상황(HP 25% 이하 진입)을 이벤트라는 개념으로 추상화시키고, 그 상황에 해야 할 일을 이벤트 핸들러 같은 형태로 구현한다는 부분을 부각시켜서 보여드리고 싶었습니다.

이런 추상화 구조를 기반으로 MFC는 윈도우 메시지 루프 자체를 코드에서 은폐시켜버리고, 각 메시지를 처리할 함수를 메시지 핸들러라는 형태로 따로따로 구현할 수 있도록 했죠.

조금 시야를 확장해서 보면, 여기저기서 많이 사용하는 State machine 또한 콜백 구조라고 볼 수 있습니다. 매 프레임마다 호출될 콜백 함수는 정해져있지만, 현재의 State가 무엇이냐에 따라 누가 호출될지가 달라지고, 각 State의 구현에서는 다른 State일 때의 상황을 (거의) 고려하지 않아도 되는 거지요.

그리고 위의 예에서 언급되지 않은 부분이 있는데, 맨날놀아 님과 엑스터님께서 말씀하신 구현 예 중 비동기 I/O 방식입니다. 이건 보통 쓰레드가 나뉘는게 일반적이니 위의 예와는 달리, 콜백 함수가 별도의 쓰레드에서 메인 쓰레드의 상황과는 관계없이 실행된다고 보는 게 맞겠지요. 그래서 쓰레드 동기화 이슈를 핸들링해야 하는 부담이 조금 발생합니다.

멀티 쓰레드로 만든대도 그래봐야 어떤 쓰레드가 결국 완료됐는지 계속 체크해야 하는 거 아닌가? 하고 생각하실 수도 있는데, 그건 조금 다릅니다. 비동기 I/O 같은 경우 완료 시점에 어떤 형태로 알림을 받는지가 몇 가지 방식이 있는데,

1. 엑스터님께서 언급하신 콜백 함수만 주고, 그 함수를 어떤 쓰레드가 실행하는 건지는 프로그래머는 상관하지 않는 방식. C#의 비동기 I/O가 대개 이렇습니다. C# 비동기 I/O의 기반은 IOCP인데, 쓰레드 관리까지 기본적으로 알아서 해줘서 콜백이 호출될 쓰레드가 어떤 건지 예측을 못합니다.

2. I/O를 요청했던 쓰레드에서 특정 함수들(쓰레드를 alertable wait state로 전환하는 함수들) 중에 하나가 실행됐을 때 I/O 완료 정보가 있으면 지정했던 콜백을 그 쓰레드가 실행하도록 해주고, 그 콜백 함수가 끝나면 아까 호출했던 특정 함수(SleepEx 같은 거) 이후로 돌아오는 방식. APC(Asynchronous Procedure Call)라는 방식입니다. IOCP 이전에 반짝 했었는데, I/O를 요청한 쓰레드가 핸들러도 직접 실행해야 하기 때문에 SleepEx 같은 함수를 꼭 여기저기서 호출해줘야 하고, 이 구조 때문에 쓰레드간 부하 분산이 적절히 되지 않는 문제가 있어서 IOCP 등장 이후 패망의 길을 걷습니다.

3. I/O 완료 시 알림을 받을 쓰레드를 미리 몇 개 생성해두고 잠재워둔 뒤(쓰레드 풀), 뭔가 완료됐을 때 OS가 그 쓰레드들 중 하나를 깨워서 완료 정보를 넘겨주는 방식. Windows의 IOCP가 이렇습니다.

4. 원초적으로 이벤트 커널 객체의 핸들 값에 대고 특정 쓰레드가 WaitForSingle/MultipleObject 함수를 호출해서 대기타는 방식. OS가 해당 이벤트 핸들에 시그널을 주는 경우라면 이렇게 구현할 수도 있겠죠.

이거 외에도 더 많이 있을 겁니다. Unix/Linux 계열에는 IOCP 대신 Event polling 이라는 방식도 있고, 다른 것도 더 있을 건데, 제가 MS의 노예라 잘 모릅니다 ㅠㅜ;;

다만, 이 틀을 만드는 프로그래머 입장이 아니라, 틀이 갖춰진 상태에서 이벤트 핸들러만 구현하는 프로그래머 입장에서는 콜백 함수(이벤트 핸들러)만 잘 작성하면 기존의 틀 내부를 파악하지 않고도 작업이 가능하겠지요. MFC 사용자가 MFC가 어떻게 메시지를 처리해서 OnKeyDown 같은 함수가 호출되게 했는지 신경쓰지 않아도 되듯이요.

읽기 피곤하실만큼 긴 글이었겠지만 도움이 되셨으면 좋겠네요. : )

제가 좀 쉽고 , 간단하게 설명하자면

설계할때 이벤트 처리를 어떻게 할것이냐 차이입니다

보통 콜백 방식은  기존 메인 로직을 건들지 않고  메인의 특정 로직이 동작할때 , 외부 로직에서 하고 싶은 일을 콜백으로 걸어놓는것입니다
이건 해당 로직 설계를 견고하게 싶을때 주로 사용하며 ,주로 엔진이나 메인 프레임급에서 사용되고
그러한 엔진급 라이브러리에서,  다른 로직에  의존성없이 독립성 있는 설계를 할때 주로 사용됩니다

따라서 예를 들어 엔진이나 라이브러리를 막 고쳐 쓰고 싶은 사람들에게는 상당히 불편하지만 ,
엔진이나 라이브러리를  그대로 이용할 사람들에게는 아주 견고한 프레임웍이 제공되는 셈이죠

대표적인게 물리엔진이고
상용급 라이브리러, 혹은  공개용으로는 오우거 랜더링 엔진이나 비싼 엔진들이 주로

유저 로직 연동을 그렇게 하는거 겉습니다


그리고 질문자가 생각하신 순차구조라는게 어차피 코드를 다 접근해서 돌린다는 개념같습니다
[ 일단 이건 쓰레드와는 아무 상관없고요 ]

질문자가 생각은 루프를 돌며
어차피 순차구조로 함수 호출하고 리턴값 받아서 처리하는 구조로 다 접근해 처리할텐데
 뭐하러 콜백같은걸 귀찬게 등록할까라는 생각이 들어서 일거라 추정해봅니다

콜백의 장점을 이해하지 못하면 , 콜백으로 처리하는건 대단히 귀찬고 비용이 많이 들어간다 생각하기 쉽거든요
[ 제일 먼저 콜백을 이해 못할때 오는 가장 큰 단점이 ,  콜백으로 처리하면 ,  흐름이 바로 직관적으로 파악이 되지는 않는거죠 ]

하지만 엔진 같이 핵심 로직이 견고해야하는 곳에는 필수적입니다

[ 참고로 콜백 함수가 아니라 콜백 이벤트, 메세지  같은것 등등 , 콜백에는 다양한 종류가 있겠습니다
   예를 들어  유니티 스크립트의 함수들도 다 콜백함수 입니다  ]


유명한 라이브러리 나 프레임 웍  및 엔진을 쓸때  아마도 , 많은 종류의 콜백을 제공했을텐데
이게다 독립적이고 응집성있는  설계를 위한 가장 좋은 방법이기 때문입니다

하지만 그런 프레임웍만으로 처리하기에는 불편하고 막  뜯어 로직을 때려박으면서  빠르게
개발하고 싶은 사람들을 위해 , 제공되는 프레임웍도 있습니다

이게 많은 귀찬느니즘 프로그래머의 욕구이기에 ........

캐주얼 게임 같이  빠르고 쉽게 개발할때는 , 거창한 엔진기능이 제공되는 엔진보단
게임브리오 류 엔진처럼  사용하는 프로그래머 입장에선 편리를 고려한 설계도 많이 합니다

로직 코드 자체를  해당 모듈에  박아 버릴수 있게  엔진 내부를 유연하게? 공개하고 ,
엔진 사용자 프로그래머가  쉽게 때려 박을수 있게 메뉴얼화까지 해놓은것이죠

대신 그런 엔진은 프로그래머들이 쉽게 엔진 코드를 건들 수 있다는걸 고려해야하므로 ,
모듈간 응집성이 떨어지게되어   심도 있는 기능은 제공하기 어렵다는 단점이 있습니다
[그런 엔진은 기능이 대단히 심플 합니다 ]

따라서 쉽고 편한것만 추구하면 솔직히 필요없을수도 있으나
중견급 프로그래머 이상 가고 싶다면 콜백에 대한 이해는 필수입니다


혹시라도 말씀 드리지만 어디까지나 바로 바로 수정하는 로직단에서는 굳이 콜백이 꼭 필요하지
않을수 있으며  ,  말씀하신 키보드 flag 리턴값처럼 , 처리가능한곳이 대부분이므로
설계에 있어서 콜백은 선택 사항입니다.

하지만 리턴값으로 처리한다는건 이미 로직 흐름이 끝났을때나 받아 처리할수 있기때문에 그렇게만
설계할수 있는 한계가 명확히 있습니다

설계자 입장에선
다양한 모듈이 응집해서 돌아가야 할 경우
그 응집성 중간에, 흐림이 끊이지 않고 ,  외부 코드를 직접 넣지 않게  콜백함수를 등록 처리 한다
고만 생각하면 무리는 없을것입니다


결론은

1. 외부 의존성있는 코드를 직접 넣지 않을수 있으므로 ,  외부 독립적으로 만듬
2  응집성있는 코드들의 흐름이 깨어지지 않으면서 외부 코드가 수행될수 있는 여지를 줄수 있게해줌


입니다



콜백에 대한 이해가 바르지 못했을때 오는 문제의 예를 하나 들어들이면

모 자체 엔진쓰는 회사에선 게임 엔진에 대한 이해부족으로 ,렌더링 엔진에  로직 자체를 박는 경우가 있었습니다
로직에 꼭 필요한 코드인데 콜백 개념이 없어서  그냥 엔진에 박는 실수를 범한것이죠

자체엔진이긴 하지만 렌더링 엔진에    렌더링과 관련없는 이상한 결제 시스템 같은 로직이 덕지 덕지 붙어 있다고 생각해 보시면
끔직하죠 (결제 시스템은 불필요한 로직이라는 가상의 예임 )

엔진 설계에 대한 이해가 있는 프로그래머가   콜백함수 하나만 제공해더라면 그런 참사는 막을수 있었을텐데
함수 포인터도 모르는 프로그래머들이  로직를 짜고 있었죠

그 프로그래머들은  2-3년차 프로그래머 들 였습니다......
